<?php

namespace Raidoxx\Entities\monsters;

use pocketmine\entity\Entity;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\entity\Location;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\item\VanillaItems;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\protocol\types\entity\EntityIds;
use pocketmine\network\mcpe\protocol\types\entity\EntityMetadataFlags;
use pocketmine\network\mcpe\protocol\types\entity\MetadataProperty;
use pocketmine\player\Player;
use pocketmine\world\sound\IgniteSound;
use pocketmine\world\sound\Sound;
use Raidoxx\Entities\Atributes;
use Raidoxx\Entities\IA\types\ComplexIA;
use Raidoxx\Entities\RDXBaseMob;
use Raidoxx\Entities\Temperament;
use Raidoxx\Libs\pathfinder\setting\rule\DefaultPathRules;
use Raidoxx\Libs\pathfinder\setting\Settings;
use Raidoxx\Main;

class Creeper extends RDXBaseMob
{
    public static string $networkId = EntityIds::CREEPER;
    public float $width = 0.6;
    public float $height = 1.7;
    public float $eyeHeight = 1.65;
    /**
     * @var true
     */
    private bool $inExplosion = false;

    public function getName(): string
    {
        return "Creeper";
    }

    public function __construct(Location $location, CompoundTag $nbt = null)
    {
        parent::__construct(
            $location,
            new EntitySizeInfo($this->height, $this->width, $this->eyeHeight),
            self::$networkId,
            $this->getName(),
            new ComplexIA($this),
            new Temperament(Temperament::AGGRESSIVE),
            new Atributes(2, 4, 35, 4,15, 5, 20),
            Settings::get()->setPathRules(new DefaultPathRules()),
            new CompoundTag()
        );
        $this->getAtributes()->setExplosive(true);
        $this->getEnemyManager()->addEnmies(Player::class);
    }

    public function getDrops() : array{
        return [
            VanillaItems::GUNPOWDER()->setCount(mt_rand(0, 2))
        ];
    }

    public function entityBaseTick(int $tickDiff = 10): bool
    {
        if($this->inExplosion){
            $this->getAttackManager()->process(null);
        }
        return parent::entityBaseTick($tickDiff); // TODO: Change the autogenerated stub
    }

    /*
     *  public void setPowered(boolean charged) {
        this.setDataFlag(DATA_FLAGS, DATA_FLAG_POWERED, charged);
    }
     */
    public function setPowered(bool $value = true): void
    {
        $this->getNetworkProperties()->setGenericFlag(EntityMetadataFlags::POWERED, $value);
    }

    public function isPowered(): bool
    {
        $meta = $this->getNetworkProperties()->getAll()[EntityMetadataFlags::POWERED];
        return $meta instanceof MetadataProperty ? $meta->getValue() : false;
    }

    /*
     *  public boolean onInteract(Player player, Item item, Vector3 clickedPos) {
        if (item.getId() == Item.FLINT_AND_STEEL && !exploding) {
            this.exploding = true;
            level.addLevelSoundEvent(this, LevelSoundEventPacket.SOUND_IGNITE);
            this.setDataFlag(DATA_FLAGS, DATA_FLAG_IGNITED, true);
            this.level.addSound(this, Sound.RANDOM_FUSE);
            level.getServer().getScheduler().scheduleDelayedTask(null, this::explode, 30);
            return true;
        }
        return super.onInteract(player, item, clickedPos);
    }
     */

    public function onInteract(Player $player, Vector3 $clickPos): bool
    {
        if ($player->getInventory()->getItemInHand()->getTypeId() == VanillaItems::FLINT_AND_STEEL()->getTypeId() && !$this->getAttackManager()->exploding) {
            $this->getWorld()->addSound($this->getPosition(), new IgniteSound());
            $this->inExplosion = true;
            return true;
        }
        return parent::onInteract($player, $clickPos); // TODO: Change the autogenerated stub
    }
}